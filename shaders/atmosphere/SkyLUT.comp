// Adopted from: https://github.com/sebh/UnrealEngineSkyAtmosphere
// MIT License
// Copyright (c) 2020 Epic Games, Inc.
// You can find full license texts in /licenses
#include "../_Util.glsl"
#include "Common.glsl"

layout(local_size_x = 128) in;
const ivec3 workGroups = ivec3(1, 128, 1);

layout(rgba16f) restrict uniform image2D uimg_skyLUT;

uniform sampler2D usam_viewZ;
uniform sampler2D usam_transmittanceLUT;

// originView: ray origin in view space
// endView: ray end in view space
ScatteringResult computeSingleScattering(AtmosphereParameters atmosphere, vec3 rayDir) {
    ScatteringResult result = ScatteringResult(vec3(1.0), vec3(0.0));
    if (all(equal(rayDir, vec3(0.0)))) {
        return result;
    }

    vec3 originView = vec3(0.0, 0.0, 0.0);

    RaymarchParameters params;
    params.rayStart = atmosphere_viewToAtm(atmosphere, originView);

    params.cosZenith = dot(uval_shadowLightDirView, uval_upDirView);
    float cosLightTheta = -dot(rayDir, uval_shadowLightDirWorld);
    params.rayleighPhaseAngular = rayleighPhaseAngular(cosLightTheta);
    params.miePhaseAngular = miePhaseAngular(cosLightTheta, atmosphere.miePhaseG);
    params.steps = 64u;

    vec3 earthCenter = vec3(0.0);

    // Check if ray origin is outside the atmosphere
    if (length(params.rayStart) > atmosphere.top) {
        float tTop = raySphereIntersectNearest(params.rayStart, rayDir, earthCenter, atmosphere.top);
        if (tTop < 0.0) {
            return result; // No intersection with atmosphere: stop right away
        }
        params.rayStart += rayDir * (tTop + 0.001);
    }

    float tBottom = raySphereIntersectNearest(params.rayStart, rayDir, earthCenter, atmosphere.bottom);
    float tTop = raySphereIntersectNearest(params.rayStart, rayDir, earthCenter, atmosphere.top);
    float rayLen = 0.0;

    if (tBottom < 0.0) {
        if (tTop < 0.0) {
            return result; // No intersection with earth nor atmosphere: stop right away
        } else {
            rayLen = tTop;
        }
    } else {
        if (tTop > 0.0) {
            rayLen = min(tTop, tBottom);
        }
    }

    params.rayEnd = params.rayStart + rayDir * rayLen;

    return raymarchSingleScattering(atmosphere, params, usam_transmittanceLUT);
}

void main() {
    ivec2 imgSize = imageSize(uimg_skyLUT);
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);

    if (all(lessThan(pixelPos, imgSize))) {
        vec2 texCoord = (pixelPos + 0.5) / vec2(imgSize);
        AtmosphereParameters atmosphere = getAtmosphereParameters();
        vec3 rayDir = coords_polarAzimuthEqualAreaInverse(texCoord);

        ScatteringResult result = computeSingleScattering(atmosphere, rayDir);

        vec3 color = vec3(0.0);
        color += result.inScattering * PI;

        imageStore(uimg_skyLUT, pixelPos, vec4(color, 1.0));
    }
}