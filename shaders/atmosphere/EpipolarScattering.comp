// Adopted from: https://github.com/sebh/UnrealEngineSkyAtmosphere
// MIT License
// Copyright (c) 2020 Epic Games, Inc.
// You can find full license texts in /licenses
//
// Adopted from: https://github.com/GameTechDev/OutdoorLightScattering
// Apache License 2.0
// Copyright (c) 2017 Intel Corporation
// You can find full license texts in /licenses
#include "../_Util.glsl"
#include "Common.glsl"
#include "../rtwsm/RTWSM.glsl"

layout(local_size_x = 1, local_size_y = SETTING_SLICE_SAMPLES) in;
const ivec3 workGroups = ivec3(SETTING_EPIPOLAR_SLICES, 1, 1);

layout(rgba16f) uniform readonly writeonly image2D uimg_main;
layout(rgba32f) uniform readonly image2D uimg_epipolarSliceEnd;
layout(rgba16f) uniform writeonly image2D uimg_epipolarInSctr;
layout(rgba16f) uniform writeonly image2D uimg_epipolarTransmittance;
layout(r32f) uniform writeonly image2D uimg_epipolarViewZ;

uniform sampler2D usam_viewZ;
uniform sampler2D usam_transmittanceLUT;

uniform sampler2D usam_rtwsm_warpingMap;
const bool shadowHardwareFiltering0 = true;
uniform sampler2DShadow shadowtex0HW;

float sampleShadow(vec3 shadowPos) {
    vec3 sampleTexCoord = shadowPos;
    sampleTexCoord.xy = rtwsm_warpTexCoord(usam_rtwsm_warpingMap, sampleTexCoord.xy);
    return rtwsm_sampleShadowDepth(shadowtex0HW, sampleTexCoord, 0.0);
}

ScatteringResult raymarchSingleScatteringShadowed(
AtmosphereParameters atmosphere, RaymarchParameters params,
vec3 shadowStart, vec3 shadowEnd, float stepJitter,
sampler2D transmittanceLUT
) {
    ScatteringResult result = ScatteringResult(vec3(1.0), vec3(0.0));

    float rcpSteps = 1.0 / float(params.steps);
    vec3 rayStepDelta = (params.rayEnd - params.rayStart) * rcpSteps;
    float rayStepLength = length(params.rayEnd - params.rayStart) * rcpSteps;
    vec3 shaodwStepDelta = (shadowEnd - shadowStart) * rcpSteps;

    vec3 totalDensity = vec3(0.0);
    vec3 totalInSctr = vec3(0.0);
    vec3 tSampleToOrigin = vec3(1.0);

    for (uint stepIndex = 0u; stepIndex < params.steps; stepIndex++) {
        float stepIndexF = float(stepIndex) + stepJitter;
        vec3 samplePos = params.rayStart + stepIndexF * rayStepDelta;
        float sampleHeight = length(samplePos);

        vec3 sampleDensity = sampleParticleDensity(atmosphere, sampleHeight);
        vec3 sampleExtinction = computeOpticalDepth(atmosphere, sampleDensity);
        vec3 sampleOpticalDepth = sampleExtinction * rayStepLength;
        vec3 sampleTransmittance = exp(-sampleOpticalDepth);

        vec3 tSunToSample = sampleTransmittanceLUT(atmosphere, params.cosZenith, sampleHeight, transmittanceLUT);

        vec3 sampleShadowPos = shadowStart + stepIndexF * shaodwStepDelta;
        float shadow = sampleShadow(sampleShadowPos);

        vec3 sampleInSctr = shadow * tSunToSample * computeTotalInSctr(atmosphere, params, sampleDensity);

        // See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/
        vec3 sampleInSctrInt = (sampleInSctr - sampleInSctr * sampleTransmittance) / sampleExtinction;
        totalInSctr += tSampleToOrigin * sampleInSctrInt;

        tSampleToOrigin *= sampleTransmittance;
    }

    vec3 totalOpticalDepth = computeOpticalDepth(atmosphere, totalDensity);
    result.transmittance = exp(-totalOpticalDepth);

    result.inScattering = totalInSctr;

    return result;
}


// originView: ray origin in view space
// endView: ray end in view space
ScatteringResult computeSingleScattering(AtmosphereParameters atmosphere, vec3 originView, vec3 endView, float stepJitter) {
    ScatteringResult result = ScatteringResult(vec3(1.0), vec3(0.0));

    mat3 vectorView2World = mat3(gbufferModelViewInverse);

    vec3 viewDirView = normalize(endView - originView);
    vec3 viewDirWorld = normalize(vectorView2World * viewDirView);

    RaymarchParameters params;
    params.rayStart = atmosphere_viewToAtm(atmosphere, originView);

    params.cosZenith = dot(uval_shadowLightDirView, uval_upDirView);
    float cosLightTheta = -dot(viewDirWorld, uval_shadowLightDirWorld);
    params.rayleighPhase = rayleighPhase(cosLightTheta);
    params.miePhase = miePhase(cosLightTheta, atmosphere.miePhaseG);
    params.steps = 32u;
    
    vec3 rayDir = viewDirWorld;

    if (endView.z == -65536.0) {
        params.rayStart.y = max(params.rayStart.y, atmosphere.bottom + 0.5);
        vec3 earthCenter = vec3(0.0);

        // Check if ray origin is outside the atmosphere
        if (length(params.rayStart) > atmosphere.top) {
            float tTop = raySphereIntersectNearest(params.rayStart, rayDir, earthCenter, atmosphere.top);
            if (tTop < 0.0) {
                return result; // No intersection with atmosphere: stop right away
            }
            params.rayStart += rayDir * (tTop + 0.001);
        }

        float tBottom = raySphereIntersectNearest(params.rayStart, rayDir, earthCenter, atmosphere.bottom);
        float tTop = raySphereIntersectNearest(params.rayStart, rayDir, earthCenter, atmosphere.top);
        float rayLen = 0.0;

        if (tBottom < 0.0) {
            if (tTop < 0.0) {
                return result; // No intersection with earth nor atmosphere: stop right away
            } else {
                rayLen = tTop;
            }
        } else {
            if (tTop > 0.0) {
                rayLen = min(tTop, tBottom);
            }
        }

        params.rayEnd = params.rayStart + rayDir * rayLen;
        return raymarchSingleScattering(atmosphere, params, usam_transmittanceLUT);
    } else {
        params.rayEnd = atmosphere_viewToAtm(atmosphere, endView);

        vec4 originScene = gbufferModelViewInverse * vec4(originView, 1.0);
        vec4 endScene = gbufferModelViewInverse * vec4(endView, 1.0);

        vec4 originShadowCS = global_shadowRotationMatrix * shadowProjection * shadowModelView * originScene;
        vec4 endShadowCS = global_shadowRotationMatrix * shadowProjection * shadowModelView * endScene;

        vec3 startShadow = originShadowCS.xyz / originShadowCS.w;
        startShadow = startShadow * 0.5 + 0.5;
        vec3 endShadow = endShadowCS.xyz / endShadowCS.w;
        endShadow = endShadow * 0.5 + 0.5;

        return raymarchSingleScatteringShadowed(atmosphere, params, startShadow, endShadow, stepJitter, usam_transmittanceLUT);
    }
}

void main() {
    ivec2 imgSizei = ivec2(SETTING_EPIPOLAR_SLICES, SETTING_SLICE_SAMPLES);
    vec2 imgSize = vec2(SETTING_EPIPOLAR_SLICES, SETTING_SLICE_SAMPLES);
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
    uint sliceIndex = gl_WorkGroupID.x;
    uint sliceSampleIndex = gl_LocalInvocationID.y;
    vec4 sliceEndPoints = imageLoad(uimg_epipolarSliceEnd, ivec2(sliceIndex, 0));

    uint cond = uint(all(lessThan(pixelPos, imgSizei)));
    cond &= uint(isValidScreenLocation(sliceEndPoints.xy)) | uint(isValidScreenLocation(sliceEndPoints.zw));

    if (bool(cond)) {
        float ignValue = rand_IGN(vec2(gl_GlobalInvocationID.xy), frameCounter);
        float sliceSampleP = float(sliceSampleIndex);
        sliceSampleP += ignValue - 0.5;
        sliceSampleP /= float(SETTING_SLICE_SAMPLES - 1);

        vec2 texCoord = mix(sliceEndPoints.xy, sliceEndPoints.zw, sliceSampleP) * 0.5 + 0.5;
        texCoord = (round(texCoord * global_mainImageSize) + 0.5) * global_mainImageSizeRcp;

        AtmosphereParameters atmosphere = getAtmosphereParameters();
        float viewZ = textureLod(usam_viewZ, texCoord, 0.0).r;
        vec3 viewCoord = coords_toViewCoord(texCoord, viewZ, gbufferProjectionInverse);

        ScatteringResult result = computeSingleScattering(atmosphere, vec3(0.0), viewCoord, ignValue);
        imageStore(uimg_epipolarInSctr, pixelPos, vec4(result.inScattering, 0.0));
        imageStore(uimg_epipolarTransmittance, pixelPos, vec4(result.transmittance, 0.0));
        imageStore(uimg_epipolarViewZ, pixelPos, vec4(viewZ));
    }
}