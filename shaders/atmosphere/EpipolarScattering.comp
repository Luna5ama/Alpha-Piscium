// Adopted from: https://github.com/sebh/UnrealEngineSkyAtmosphere
// MIT License
// Copyright (c) 2020 Epic Games, Inc.
// You can find full license texts in /licenses
//
// Adopted from: https://github.com/GameTechDev/OutdoorLightScattering
// Apache License 2.0
// Copyright (c) 2017 Intel Corporation
// You can find full license texts in /licenses
#include "../_Util.glsl"
#include "Common.glsl"
#include "../rtwsm/RTWSM.glsl"

layout(local_size_x = 1, local_size_y = SETTING_SLICE_SAMPLES) in;
const ivec3 workGroups = ivec3(SETTING_EPIPOLAR_SLICES, 1, 1);

layout(rgba16f) uniform readonly writeonly image2D uimg_main;
layout(rgba32f) uniform readonly image2D uimg_epipolarSliceEnd;
layout(rgba16f) uniform writeonly image2D uimg_epipolarInSctr;
layout(rgba16f) uniform writeonly image2D uimg_epipolarTransmittance;

uniform sampler2D usam_viewZ;
uniform sampler2D usam_transmittanceLUT;

uniform sampler2D usam_rtwsm_warpingMap;
const bool shadowHardwareFiltering0 = true;
uniform sampler2DShadow shadowtex0HW;

float sampleShadow(vec3 shadowPos) {
    vec3 sampleTexCoord = shadowPos;
    sampleTexCoord.xy = rtwsm_warpTexCoord(usam_rtwsm_warpingMap, sampleTexCoord.xy);
    return rtwsm_sampleShadowDepth(shadowtex0HW, sampleTexCoord, 0.0);
}

ScatteringResult raymarchSingleScatteringShadowed(
AtmosphereParameters atmosphere, RaymarchParameters params,
vec3 startShadow, vec3 endShadow,
sampler2D usam_transmittanceLUT
) {
    ScatteringResult result = ScatteringResult(vec3(1.0), vec3(0.0));

    float stepFraction = 1.0 / float(params.steps);
    float stepJitter = rand_IGN(vec2(gl_GlobalInvocationID.xy), frameCounter);
    float stepLength = params.rayLen / float(params.steps);
    vec3 stepDelta = params.rayDir * stepLength;

    vec3 prevDensity;
    vec3 prevRayleighInSctr;
    vec3 prevMieInSctr;

    vec3 totalDensity = vec3(0.0);
    vec3 totalRayleighInSctr = vec3(0.0);
    vec3 totalMieInSctr = vec3(0.0);
    {
        vec3 samplePos = params.origin;
        float sampleHeight = length(samplePos) - atmosphere.bottom;
        vec3 sampleDensity = sampleParticleDensity(atmosphere, sampleHeight);

        prevDensity = sampleDensity;

        vec3 tSunToSample = raymarchSampleTransmittanceLUT(atmosphere, params, samplePos, usam_transmittanceLUT);
        tSunToSample *= sampleShadow(startShadow);
        vec3 tSampleToOrigin = vec3(1.0);

        computePointDiffInSctr(sampleDensity, tSampleToOrigin, tSunToSample, prevRayleighInSctr, prevMieInSctr);
    }

    for (uint stepIndex = 1u; stepIndex <= params.steps; stepIndex++) {
        float stepIndexF = float(stepIndex) - stepJitter;
        vec3 samplePos = params.origin + (stepIndexF) * stepDelta;
        float sampleHeight = length(samplePos) - atmosphere.bottom;
        vec3 sampleDensity = sampleParticleDensity(atmosphere, sampleHeight);

        totalDensity += (prevDensity + sampleDensity) * (stepLength * 0.5);
        prevDensity = sampleDensity;

        vec3 sampleShadowPos = mix(startShadow, endShadow, stepIndexF * stepFraction);
        vec3 tSunToSample = raymarchSampleTransmittanceLUT(atmosphere, params, samplePos, usam_transmittanceLUT);
        tSunToSample *= sampleShadow(sampleShadowPos);
        vec3 tSampleToOrigin = exp(-computeOpticalDepth(atmosphere, totalDensity));

        vec3 sampleRayleightInSctr;
        vec3 sampleMieInSctr;
        computePointDiffInSctr(sampleDensity, tSampleToOrigin, tSunToSample, sampleRayleightInSctr, sampleMieInSctr);

        totalRayleighInSctr += (prevRayleighInSctr + sampleRayleightInSctr) * (stepLength * 0.5);
        totalMieInSctr += (prevMieInSctr + sampleMieInSctr) * (stepLength * 0.5);

        prevRayleighInSctr = sampleRayleightInSctr;
        prevMieInSctr = sampleMieInSctr;
    }

    vec3 totalOpticalDepth = computeOpticalDepth(atmosphere, totalDensity);
    result.transmittance = exp(-totalOpticalDepth);

    vec3 totalInSctr = vec3(0.0);
    totalInSctr += params.rayleighPhaseAngular * atmosphere.rayleighSctrCoeffAngular * totalRayleighInSctr;
    totalInSctr += params.miePhaseAngular * atmosphere.mieSctrCoeffAngular * totalMieInSctr;
    result.inScattering = totalInSctr;

    return result;
}


// originView: ray origin in view space
// endView: ray end in view space
ScatteringResult computeSingleScattering(AtmosphereParameters atmosphere, vec3 originView, vec3 endView) {
    ScatteringResult result = ScatteringResult(vec3(1.0), vec3(0.0));
    RaymarchParameters params;

    mat3 vectorView2World = mat3(gbufferModelViewInverse);

    vec3 viewDirView = normalize(endView - originView);
    vec3 viewDirWorld = normalize(vectorView2World * viewDirView);

    params.origin = atmosphere_viewToAtm(atmosphere, originView);

    vec3 sunDir = sunPosition * 0.01;
    float cosTheta = -dot(sunDir, viewDirView);
    params.cosSunZenith = dot(sunDir, upPosition * 0.01);
    params.rayleighPhaseAngular = rayleighPhaseAngular(cosTheta);
    params.miePhaseAngular = miePhaseAngular(cosTheta, atmosphere.miePhaseG);

    if (endView.z == -65536.0) {
        vec3 earthCenter = vec3(0.0, 0.0, 0.0);
        params.rayDir = viewDirWorld;

        // Check if ray origin is outside the atmosphere
        if (length(params.origin) > atmosphere.top) {
            float tTop = raySphereIntersectNearest(params.origin, params.rayDir, earthCenter, atmosphere.top);
            if (tTop < 0.0) {
                return result; // No intersection with atmosphere: stop right away
            }
            params.origin += params.rayDir * (tTop + 0.001);
        }

        float tBottom = raySphereIntersectNearest(params.origin, params.rayDir, earthCenter, atmosphere.bottom);
        float tTop = raySphereIntersectNearest(params.origin, params.rayDir, earthCenter, atmosphere.top);
        params.rayLen = 0.0;
        if (tBottom < 0.0) {
            if (tTop < 0.0) {
                return result; // No intersection with earth nor atmosphere: stop right away
            } else {
                params.rayLen = tTop;
            }
        } else {
            if (tTop > 0.0) {
                params.rayLen = min(tTop, tBottom);
            }
        }

        params.steps = 32u;
        return raymarchSingleScattering(atmosphere, params, usam_transmittanceLUT);
    } else {
        vec3 endAtm = atmosphere_viewToAtm(atmosphere, endView);

        params.rayDir = normalize(endAtm - params.origin);
        params.rayLen = length(endAtm - params.origin);

        vec4 originScene = gbufferModelViewInverse * vec4(originView, 1.0);
        vec4 endScene = gbufferModelViewInverse * vec4(endView, 1.0);

        vec4 originShadowCS = global_shadowRotationMatrix * shadowProjection * shadowModelView * originScene;
        vec4 endShadowCS = global_shadowRotationMatrix * shadowProjection * shadowModelView * endScene;

        vec3 startShadow = originShadowCS.xyz / originShadowCS.w;
        startShadow = startShadow * 0.5 + 0.5;
        vec3 endShadow = endShadowCS.xyz / endShadowCS.w;
        endShadow = endShadow * 0.5 + 0.5;

        params.steps = 32u;
        return raymarchSingleScatteringShadowed(atmosphere, params, startShadow, endShadow, usam_transmittanceLUT);
    }
}

void main() {
    ivec2 imgSize = imageSize(uimg_epipolarInSctr);
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
    uint sliceIndex = gl_WorkGroupID.x;
    uint sliceSampleIndex = gl_LocalInvocationID.y;
    vec4 sliceEndPoints = imageLoad(uimg_epipolarSliceEnd, ivec2(sliceIndex, 0));

    uint cond = uint(all(lessThan(pixelPos, imgSize)));
    cond &= uint(isValidScreenLocation(sliceEndPoints.xy)) | uint(isValidScreenLocation(sliceEndPoints.zw));

    if (bool(cond)) {
        float sliceSampleP = float(sliceSampleIndex) / float(SETTING_SLICE_SAMPLES);

        vec2 texCoord = mix(sliceEndPoints.xy, sliceEndPoints.zw, sliceSampleP);

        AtmosphereParameters atmosphere = getAtmosphereParameters();
        atmosphere.sunDirection = normalize(mat3(gbufferModelViewInverse) * (sunPosition * 0.01));
        float viewZ = textureLod(usam_viewZ, texCoord * 0.5 + 0.5, 0.0).r;

        float viewZ2 = mix(viewZ, -65536.0, float(viewZ == 1.0));
        vec3 viewCoord = coords_toViewCoord(texCoord * 0.5 + 0.5, viewZ2, gbufferProjectionInverse);

        ScatteringResult result = computeSingleScattering(atmosphere, vec3(0.0), viewCoord);
        imageStore(uimg_epipolarInSctr, pixelPos, vec4(result.inScattering, 0.0));
        imageStore(uimg_epipolarTransmittance, pixelPos, vec4(result.transmittance, 0.0));
    }
}