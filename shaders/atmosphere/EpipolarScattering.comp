// Adopted from: https://github.com/sebh/UnrealEngineSkyAtmosphere
// MIT License
// Copyright (c) 2020 Epic Games, Inc.
// You can find full license texts in /licenses
//
// Adopted from: https://github.com/GameTechDev/OutdoorLightScattering
// Apache License 2.0
// Copyright (c) 2017 Intel Corporation
// You can find full license texts in /licenses
#include "../_Util.glsl"
#include "Common.glsl"
#include "../rtwsm/RTWSM.glsl"

layout(local_size_x = 1, local_size_y = SETTING_SLICE_SAMPLES) in;
const ivec3 workGroups = ivec3(SETTING_EPIPOLAR_SLICES, 1, 1);

layout(rgba16f) uniform readonly writeonly image2D uimg_main;
layout(rgba32f) uniform readonly image2D uimg_epipolarSliceEnd;
layout(rgba16f) uniform writeonly image2D uimg_epipolarInSctr;
layout(rgba16f) uniform writeonly image2D uimg_epipolarTransmittance;
layout(r32f) uniform writeonly image2D uimg_epipolarViewZ;

uniform sampler2D usam_viewZ;
uniform sampler2D usam_transmittanceLUT;

uniform sampler2D usam_rtwsm_warpingMap;
const bool shadowHardwareFiltering0 = true;
uniform sampler2DShadow shadowtex0HW;

float sampleShadow(vec3 shadowPos) {
    vec3 sampleTexCoord = shadowPos;
    sampleTexCoord.xy = rtwsm_warpTexCoord(usam_rtwsm_warpingMap, sampleTexCoord.xy);
    return rtwsm_sampleShadowDepth(shadowtex0HW, sampleTexCoord, 0.0);
}

ScatteringResult raymarchSingleScatteringShadowed(
AtmosphereParameters atmosphere, RaymarchParameters params,
vec3 shadowStart, vec3 shadowEnd, float stepJitter,
sampler2D transmittanceLUT
) {
    ScatteringResult result = ScatteringResult(vec3(1.0), vec3(0.0));

    float rcpSteps = 1.0 / float(params.steps);
    vec3 rayStepDelta = (params.rayEnd - params.rayStart) * rcpSteps;
    float rayStepLength = length(params.rayEnd - params.rayStart) * rcpSteps;
    vec3 shaodwStepDelta = (shadowEnd - shadowStart) * rcpSteps;

    vec3 prevDensity;
    vec3 prevRayleighInSctr;
    vec3 prevMieInSctr;

    vec3 totalDensity = vec3(0.0);
    vec3 totalRayleighInSctr = vec3(0.0);
    vec3 totalMieInSctr = vec3(0.0);
    {
        vec3 samplePos = params.rayStart;
        float sampleHeight = length(samplePos);
        vec3 sampleDensity = sampleParticleDensity(atmosphere, sampleHeight);

        prevDensity = sampleDensity;

        vec3 tSunToSample = sampleTransmittanceLUT(atmosphere, params, sampleHeight, transmittanceLUT);
        vec3 tSampleToOrigin = vec3(1.0);

        tSunToSample *= sampleShadow(shadowStart);

        computePointDiffInSctr(sampleDensity, tSampleToOrigin, tSunToSample, prevRayleighInSctr, prevMieInSctr);
    }

    for (uint stepIndex = 1u; stepIndex <= params.steps; stepIndex++) {
        float stepIndexF = float(stepIndex) - stepJitter;
        vec3 samplePos = params.rayStart;
        float sampleHeight = length(samplePos);
        vec3 sampleDensity = sampleParticleDensity(atmosphere, sampleHeight);

        totalDensity += (prevDensity + sampleDensity) * (rayStepLength * 0.5);
        prevDensity = sampleDensity;

        vec3 tSunToSample = sampleTransmittanceLUT(atmosphere, params, sampleHeight, transmittanceLUT);
        vec3 tSampleToOrigin = exp(-computeOpticalDepth(atmosphere, totalDensity));

        vec3 sampleShadowPos = shadowStart + stepIndexF * shaodwStepDelta;
        tSunToSample *= sampleShadow(sampleShadowPos);

        vec3 sampleRayleightInSctr;
        vec3 sampleMieInSctr;
        computePointDiffInSctr(sampleDensity, tSampleToOrigin, tSunToSample, sampleRayleightInSctr, sampleMieInSctr);

        totalRayleighInSctr += (prevRayleighInSctr + sampleRayleightInSctr) * (rayStepLength * 0.5);
        totalMieInSctr += (prevMieInSctr + sampleMieInSctr) * (rayStepLength * 0.5);

        prevRayleighInSctr = sampleRayleightInSctr;
        prevMieInSctr = sampleMieInSctr;
    }

    vec3 totalOpticalDepth = computeOpticalDepth(atmosphere, totalDensity);
    result.transmittance = exp(-totalOpticalDepth);

    vec3 totalInSctr = vec3(0.0);
    totalInSctr += params.rayleighPhaseAngular * atmosphere.rayleighSctrCoeffAngular * totalRayleighInSctr;
    totalInSctr += params.miePhaseAngular * atmosphere.mieSctrCoeffAngular * totalMieInSctr;
    result.inScattering = totalInSctr;

    return result;
}


// originView: ray origin in view space
// endView: ray end in view space
ScatteringResult computeSingleScattering(AtmosphereParameters atmosphere, vec3 originView, vec3 endView, float stepJitter) {
    ScatteringResult result = ScatteringResult(vec3(1.0), vec3(0.0));

    mat3 vectorView2World = mat3(gbufferModelViewInverse);

    vec3 viewDirView = normalize(endView - originView);
    vec3 viewDirWorld = normalize(vectorView2World * viewDirView);

    RaymarchParameters params;
    params.rayStart = atmosphere_viewToAtm(atmosphere, originView);
    params.rayStart.y += 1.0;
    
    float cosTheta = -dot(uval_sunDirView, viewDirView);
    params.cosZenith = dot(uval_sunDirView, uval_upDirView);
    params.rayleighPhaseAngular = rayleighPhaseAngular(cosTheta);
    params.miePhaseAngular = miePhaseAngular(cosTheta, atmosphere.miePhaseG);
    params.steps = 32u;
    
    vec3 rayDir = viewDirWorld;

    if (endView.z == -65536.0) {
        vec3 earthCenter = vec3(0.0);

        // Check if ray origin is outside the atmosphere
        if (length(params.rayStart) > atmosphere.top) {
            float tTop = raySphereIntersectNearest(params.rayStart, rayDir, earthCenter, atmosphere.top);
            if (tTop < 0.0) {
                return result; // No intersection with atmosphere: stop right away
            }
            params.rayStart += rayDir * (tTop + 0.001);
        }

        float tBottom = raySphereIntersectNearest(params.rayStart, rayDir, earthCenter, atmosphere.bottom);
        float tTop = raySphereIntersectNearest(params.rayStart, rayDir, earthCenter, atmosphere.top);
        float rayLen = 0.0;

        if (tBottom < 0.0) {
            if (tTop < 0.0) {
                return result; // No intersection with earth nor atmosphere: stop right away
            } else {
                rayLen = tTop;
            }
        } else {
            if (tTop > 0.0) {
                rayLen = min(tTop, tBottom);
            }
        }

        params.rayEnd = params.rayStart + rayDir * rayLen;
        return raymarchSingleScattering(atmosphere, params, usam_transmittanceLUT);
    } else {
        params.rayEnd = atmosphere_viewToAtm(atmosphere, endView);

        vec4 originScene = gbufferModelViewInverse * vec4(originView, 1.0);
        vec4 endScene = gbufferModelViewInverse * vec4(endView, 1.0);

        vec4 originShadowCS = global_shadowRotationMatrix * shadowProjection * shadowModelView * originScene;
        vec4 endShadowCS = global_shadowRotationMatrix * shadowProjection * shadowModelView * endScene;

        vec3 startShadow = originShadowCS.xyz / originShadowCS.w;
        startShadow = startShadow * 0.5 + 0.5;
        vec3 endShadow = endShadowCS.xyz / endShadowCS.w;
        endShadow = endShadow * 0.5 + 0.5;

        return raymarchSingleScatteringShadowed(atmosphere, params, startShadow, endShadow, stepJitter, usam_transmittanceLUT);
    }
}

void main() {
    ivec2 imgSizei = ivec2(SETTING_EPIPOLAR_SLICES, SETTING_SLICE_SAMPLES);
    vec2 imgSize = vec2(SETTING_EPIPOLAR_SLICES, SETTING_SLICE_SAMPLES);
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
    uint sliceIndex = gl_WorkGroupID.x;
    uint sliceSampleIndex = gl_LocalInvocationID.y;
    vec4 sliceEndPoints = imageLoad(uimg_epipolarSliceEnd, ivec2(sliceIndex, 0));

    uint cond = uint(all(lessThan(pixelPos, imgSizei)));
    cond &= uint(isValidScreenLocation(sliceEndPoints.xy)) | uint(isValidScreenLocation(sliceEndPoints.zw));

    if (bool(cond)) {
        float ignValue = rand_IGN(vec2(gl_GlobalInvocationID.xy), frameCounter);
        float sliceSampleP = float(sliceSampleIndex);
        sliceSampleP += ignValue - 0.5;
        sliceSampleP /= float(SETTING_SLICE_SAMPLES - 1);

        vec2 texCoord = mix(sliceEndPoints.xy, sliceEndPoints.zw, sliceSampleP) * 0.5 + 0.5;
        texCoord = (round(texCoord * global_mainImageSize) + 0.5) * global_mainImageSizeRcp;

        AtmosphereParameters atmosphere = getAtmosphereParameters();
        atmosphere.sunDirection = normalize(mat3(gbufferModelViewInverse) * uval_sunDirView);
        float viewZ = textureLod(usam_viewZ, texCoord, 0.0).r;
        vec3 viewCoord = coords_toViewCoord(texCoord, viewZ, gbufferProjectionInverse);

        ScatteringResult result = computeSingleScattering(atmosphere, vec3(0.0), viewCoord, ignValue);
        imageStore(uimg_epipolarInSctr, pixelPos, vec4(result.inScattering, 0.0));
        imageStore(uimg_epipolarTransmittance, pixelPos, vec4(result.transmittance, 0.0));
        imageStore(uimg_epipolarViewZ, pixelPos, vec4(viewZ));
    }
}