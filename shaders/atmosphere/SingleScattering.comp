// Adopted from: https://github.com/sebh/UnrealEngineSkyAtmosphere
// MIT License
// Copyright (c) 2020 Epic Games, Inc.
// You can find the full license texts in /licenses
#include "../_Util.glsl"
#include "Common.glsl"

layout(local_size_x = 128, local_size_y = 1) in;
const vec2 workGroupsRender = vec2(1.0, 1.0);

layout(rgba16f) restrict uniform image2D uimg_main;

uniform sampler2D usam_viewZ;
uniform sampler2D usam_transmittanceLUT;

// originView: ray origin in view space
// endView: ray end in view space
ScatteringResult computeSingleScattering(AtmosphereParameters atmosphere, vec3 originView, vec3 endView) {
    ScatteringResult result = ScatteringResult(vec3(1.0), vec3(0.0));
    RaymarchParameters params;

    mat3 vectorView2World = mat3(gbufferModelViewInverse);

    vec3 viewDirView = normalize(endView - originView);
    vec3 viewDirWorld = vectorView2World * viewDirView;

    vec3 originFeetPlayer = (gbufferModelViewInverse * vec4(originView, 1.0)).xyz;
    vec3 originWorld = originFeetPlayer + cameraPosition;
    float originAltitude = calcViewAltitude(atmosphere, originWorld);

    params.origin = vec3(originFeetPlayer.x, 0.0, originFeetPlayer.z) / SETTING_ATM_D_SCALE;
    params.origin.y += originAltitude;

    if (endView.z == -65536.0) {
        vec3 earthCenter = vec3(0.0, 0.0, 0.0);
        params.rayDir = viewDirWorld;

        // Check if ray origin is outside the atmosphere
        if (length(params.origin) > atmosphere.top) {
            float tTop = raySphereIntersectNearest(params.origin, params.rayDir, earthCenter, atmosphere.top);
            if (tTop < 0.0) {
                return result; // No intersection with atmosphere: stop right away
            }
            params.origin += params.rayDir * (tTop + 0.01);
        }

        float tBottom = raySphereIntersectNearest(params.origin, params.rayDir, earthCenter, atmosphere.bottom);
        float tTop = raySphereIntersectNearest(params.origin, params.rayDir, earthCenter, atmosphere.top);
        params.rayLen = 0.0;
        if (tBottom < 0.0) {
            if (tTop < 0.0) {
                return result; // No intersection with earth nor atmosphere: stop right away
            } else {
                params.rayLen = tTop;
            }
        } else {
            if (tTop > 0.0) {
                params.rayLen = min(tTop, tBottom);
            }
        }
    } else {
        vec3 endFeetPlayer = (gbufferModelViewInverse * vec4(endView, 1.0)).xyz;
        vec3 endWorld = endFeetPlayer + cameraPosition;
        float endAltitude = calcViewAltitude(atmosphere, endWorld);

        vec3 endAtm = vec3(endFeetPlayer.x, 0.0, endFeetPlayer.z) / SETTING_ATM_D_SCALE;
        endAtm.y += endAltitude;

        params.rayDir = normalize(endAtm - params.origin);
        params.rayLen = length(endAtm - params.origin);
    }

    vec3 sunDir = sunPosition * 0.01;
    float cosTheta = -dot(sunDir, viewDirView);
    params.cosSunZenith = dot(sunDir, upPosition * 0.01);
    params.rayleighPhaseAngular = rayleighPhaseAngular(cosTheta);
    params.miePhaseAngular = miePhaseAngular(cosTheta, atmosphere.miePhaseG);
    params.steps = 64u;

    return raymarchSingleScattering(atmosphere, params, usam_transmittanceLUT);
}

void main() {
    ivec2 imgSize = imageSize(uimg_main);
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);

    if (all(lessThan(pixelPos, imgSize))) {
        vec2 texCoord = (pixelPos + 0.5) / vec2(imgSize);
        AtmosphereParameters atmosphere = getAtmosphereParameters();
        atmosphere.sunDirection = mat3(gbufferModelViewInverse) * (sunPosition * 0.01);
        float viewZ = texelFetch(usam_viewZ, pixelPos, 0).r;

        float viewZ2 = mix(viewZ, -65536.0, float(viewZ == 1.0));
        vec3 viewCoord = coords_toViewCoord(texCoord, viewZ2, gbufferProjectionInverse);

        ScatteringResult result = computeSingleScattering(atmosphere, vec3(0.0), viewCoord);

        vec4 color = imageLoad(uimg_main, pixelPos);
        color.rgb *= result.transmittance;

        vec3 sunRadiance = global_sunRadiance.rgb * global_sunRadiance.a;
        color.rgb += sunRadiance * result.inScattering;

        imageStore(uimg_main, pixelPos, color);
    }
}