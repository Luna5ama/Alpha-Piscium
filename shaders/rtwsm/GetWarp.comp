#pragma optionNV (unroll all)

#extension GL_KHR_shader_subgroup_arithmetic : enable

#include "../_Util.glsl"

layout(local_size_x = SETTING_RTWSM_IMAP_SIZE, local_size_y = 1, local_size_z = 1) in;
const ivec3 workGroups = ivec3(1, 2, 1);

layout(r32f) uniform readonly image2D uimg_rtwsm_imap1D;
layout(rg16_snorm) uniform writeonly image2D uimg_rtwsm_warpingMap;

shared float shared_prefixBuffer[gl_NumSubgroups];

void main() {
    shared_prefixBuffer[gl_LocalInvocationID.x] = 0.0;
    barrier();

    ivec2 ti = ivec2(gl_GlobalInvocationID.xy);
    float tValue = imageLoad(uimg_rtwsm_imap1D, ti).r;
    float prefix = subgroupInclusiveAdd(tValue);
    if (gl_SubgroupInvocationID == gl_SubgroupSize - 1) {
        shared_prefixBuffer[gl_SubgroupID] = prefix;
    }
    barrier();

    float tValue2 = shared_prefixBuffer[gl_LocalInvocationID.x];
    barrier();
    if (gl_SubgroupID == 0) {
        float prefix2 = subgroupInclusiveAdd(tValue2);
        shared_prefixBuffer[gl_LocalInvocationID.x] = prefix2;
    }
    barrier();

    prefix += gl_SubgroupID == 0 ? 0.0 : shared_prefixBuffer[gl_SubgroupID - 1];
    barrier();

    float k = float(gl_LocalInvocationID.x + 1);
    float n = float(gl_WorkGroupSize.x);

    float prefixExcl = prefix - tValue;
    float total = shared_prefixBuffer[gl_NumSubgroups - 1];
    float warp = (prefixExcl / total) - (k / n);
    float texelSize = tValue / max(total, 1.0);

    imageStore(uimg_rtwsm_warpingMap, ti, vec4(warp, texelSize, 0.0, 0.0));
}
