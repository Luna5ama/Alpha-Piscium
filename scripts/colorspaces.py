import colour
import numpy as np

sorted(colour.RGB_COLOURSPACES)

def getColorSpace(csname):
    if csname == 'Color McSpaceFace':
        d65 = [0.31272, 0.32903]
        r = [0.671893,  0.330215]
        g = [0.203233,  0.814212]
        b = [0.120590,  0.038494]
        return colour.RGB_Colourspace(
            name='Custom',
            primaries=np.array([r, g, b]),
            whitepoint=np.array(d65),
            whitepoint_name='D65',
            matrix_RGB_to_XYZ=None,
            matrix_XYZ_to_RGB=None,
            cctf_encoding=None,
            cctf_decoding=None
        )

    try:
        return colour.RGB_COLOURSPACES[csname]
    except KeyError:
        raise ValueError(f"Color space '{csname}' not found in colour-science library.")

def cmat(a, b):
    if a == b:
        return np.identity(3)
    elif (a == "CIE XYZ"):
        mat = getColorSpace(b).matrix_XYZ_to_RGB
    elif (b == "CIE XYZ"):
        mat = getColorSpace(a).matrix_RGB_to_XYZ
    else:
        mat = colour.matrix_RGB_to_RGB(
            getColorSpace(a),
            getColorSpace(b),
            'Bradford'
        )

    return np.round(mat, decimals=10)

my_color_spaces = [
    "CIE XYZ",
    "sRGB",
    "ITU-R BT.709",
    "ITU-R BT.2020",
    "DCI-P3",
    "Adobe RGB (1998)",
    "ACES2065-1",
    "ACEScg",
    "Color McSpaceFace"
]

color_space_code_name = {
    "CIE XYZ": "CIE_XYZ",
    "sRGB": "SRGB",
    "ITU-R BT.709": "REC709",
    "ITU-R BT.2020": "REC2020",
    "DCI-P3": "DCI_P3",
    "Adobe RGB (1998)": "ADOBE_RGB_1998",
    "ACES2065-1": "ACES_AP0",
    "ACEScg": "ACES_AP1",
    "Color McSpaceFace": "COLOR_MCSPACEFACE"
}

package_name = "colors2_colorspaces"
max_line_length = 120

def section_separator_string(s):
    curr = s
    total_num_dashes = max_line_length - len(curr) - 5
    num_dashes_each_side = total_num_dashes // 2
    dashes = '-' * num_dashes_each_side
    return f"// {dashes} {curr} {dashes}"

print("// This file is auto-generated by /scripts/colorspaces.py")
print(section_separator_string("API"))

for idx, name in enumerate(my_color_spaces):
    code_name = color_space_code_name[name]
    print(f"#define {package_name.upper()}_{code_name} {idx}")

print("")
print(f"#define _{package_name}_convert(a, b, x) {package_name}_ ## a ## _to_ ## b ##(x)")
print(f"#define {package_name}_convert(a, b, x) _{package_name}_convert(a, b, x)")
print(f"#define _{package_name}_luma(a, x) {package_name}_ ## a ## _luma(x)")
print(f"#define {package_name}_luma(a, x) _{package_name}_luma(a, x)")
print("\n")
print(section_separator_string("Conversion Matrices"))

for a_idx, a in enumerate(my_color_spaces):
    a_name = color_space_code_name[a]
    print(section_separator_string(f"From {a_name}"))
    for b_idx, b in enumerate(my_color_spaces):
        b_name = color_space_code_name[b]
        mat = cmat(a, b)
        mat_name = f"_{package_name}_mat_{a_name}_to_{b_name}"
        print(f"const mat3 {mat_name} = mat3(")
        print(",\n".join("    "+ ", ".join(str(x) for x in row) for row in mat))
        print(");")

    print("")

print("")
print(section_separator_string("Luma Functions"))

for a_idx, a in enumerate(my_color_spaces):
    if a == "CIE XYZ":
        continue
    a_name = color_space_code_name[a]
    a_to_xyz_mat_name = f"_{package_name}_mat_{a_name}_to_CIE_XYZ"
    print(f"#define {package_name}_{a_name}_luma(x) dot(x, {a_to_xyz_mat_name}[1])")
    print(f"#define {package_name}_{a_idx}_luma(x) {package_name}_{a_name}_luma(x)\n")

print("")
print(section_separator_string("Adapter Functions"))

for a_idx, a in enumerate(my_color_spaces):
    a_name = color_space_code_name[a]
    print(section_separator_string(f"From {a_name}"))
    for b_idx, b in enumerate(my_color_spaces):
        b_name = color_space_code_name[b]
        mat = cmat(a, b)
        mat_name = f"_{package_name}_mat_{a_name}_to_{b_name}"
        print(f"#define {package_name}_{a_name}_to_{b_name}(x) (x * {mat_name})")
        print(f"#define {package_name}_{a_idx}_to_{b_idx}(x) {package_name}_{a_name}_to_{b_name}(x)\n")

    print("")
